# 동적 배열

1. [정의](#정의)
2. [특징](#특징)
   1. [더블링(Doubling)](#더블링doubling)
   2. [분할상환 시간복잡도(Amortized time complexity)](#분할상환-시간복잡도amortized-time-complexity)
   3. [장점](#장점)
   4. [단점](#단점)

## 정의

배열의 경우 크기가 고정되어 있기 때문에 선언시에 설정한 크기보다 더 많은 수의 데이터가 추가되면 저장할 수 없다. 반대로 동적 배열은 저장공간이 가득 차게 될 경우 resize를 하여 유동적으로 크기를 조절해 데이터를 저장하는 자료구조다.

## 특징

동적 배열은 크기를 **자동적으로 리사이징(resizing)하는 배열**이다. 기존에 **고정된 크기를 가진 정적 배열(Static Array)의 한계점을 보완하고자 고안**되었다.

동적 배열은 데이터를 계속 추가하다가 기존에 할당된 메모리를 초과하게 되면, **사이즈를 늘린 배열을 선언하고 그곳으로 모든 데이터를 옮김**으로써 늘어난 크기의 사이즈를 가진 배열이 된다. 이를 **resize**라고 한다. 이로써 새로운 데이터를 저장할 수 있게 된다. 따라서 동적 배열은 **크기를 미리 고민할 필요가 없다**는 장점이 있다.

리사이징을 하는 방법은 여러 가지가 있는데, 대표적으로 기존 배열 크기의 2배를 할당하는 더블링(doubling)이 있다.

### 더블링(Doubling)

리사이즈의 대표적인 방법으로는 더블링(Doubling)이 있다. 데이터를 추가(append `O(1)`)하다가 메모리를 초과하게 되면 기존 배열의 크기보다 **두배 큰 배열을 선언하고 데이터를 일일이 옮기는 방법**(n개의 데이터를 일일이 옮기므로 `O(n)`)이다.

### 분할상환 시간복잡도(Amortized time complexity)

1. 동적 배열에 데이터를 추가할 때마다 `O(1)`의 시간이 소모된다.
2. 추가하다가 미리 선언된 크기를 넘어서는 순간 리사이즈를 수행한다.
3. 이 경우 모든 데이터를 일일이 옮겨야 하기 때문에 `O(n)`의 시간이 소모된다.

이같은 상황에서 append의 시간복잡도가 `O(1)`와 `O(n)` 중 무엇일지 판단해보면 다음과 같다.

append의 전체 과정을 살펴보면 데이터를 마지막 인덱스에 추가하는 `O(1)` 작업이 대다수이고, 크기를 넘어설 때는 사이즈를 두배 늘리고 데이터를 일일이 옮기는 과정(resize `O(n)`)이 아주 가끔 발생한다. 결론을 먼저 말하면 append의 전체적인 시간복잡도는 `O(1)`이다. 조금 더 정확히 말하면 **amortized** `O(1)`이라고 부른다.

쉽게 설명하면 드물게 발생하는 `O(n)`의 리사이즈 수행 시간을, 자주 발생하는 `O(1)` 작업들이 분담해서 나누어 가짐으로써 전체적으로 `O(1)`의 시간이 걸린다고 생각하면 된다.

### 장점

링크드 리스트와 비교했을 때 동적 배열의 장점은 다음과 같다.

- **데이터 접근과 할당이 `O(1)`로 굉장히 빠르다.** 이는 인덱스로 접근하는 방법이 산술적인 연산 `[배열 첫 데이터의 주소값] + [offset]` 으로 이루어져 있기 때문이다. (Random Access, 무작위 접근)
- 동적 배열의 맨 뒤에 데이터를 추가하거나 삭제하는 것이 상대적으로 빠르다. (`O(1)`)

### 단점

링크드 리스트와 비교했을 때 동적 배열의 단점은 다음과 같다.

- 동적 배열의 **맨 끝이 아닌 곳에 데이터를 삽입(insert) 또는 삭제(remove)할 때, 느린 편**이다. (`O(n)`) 느린 이유는 메모리상에서 연속적으로 데이터들이 저장되어 있기 때문에, 데이터를 추가, 삭제할 때 뒤에 있는 데이터들을 모두 한칸씩 **shift** 해야하기 때문이다.
- 리사이즈를 해야할 때, 예상치 못하게 현저히 낮은 퍼포먼스가 발생한다.
- 리사이즈에 시간이 많이 소모되므로 필요 이상의 메모리 공간을 할당받는다. 따라서 사용하지 않고 낭비되는 메모리 공간이 발생한다.
