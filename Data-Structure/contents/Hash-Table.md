# 해시 테이블

1. [정의](#정의)
   1. [유래 - 직접 주소화 테이블(Direct-address Table)](#유래---직접-주소화-테이블direct-address-table)
2. [특징](#특징)
3. [해시의 충돌(Collision)](#해시의-충돌collision)
   1. [좋은 해시 함수(Hash Function)이란?](#좋은-해시-함수hash-function이란)
4. [충돌 해결](#충돌-해결)
   1. [개방 주소화(Open Addressing)](#개방-주소화open-addressing)
   2. [체이닝(Separete Chaining)](#체이닝separete-chaining)
5. [시간복잡도와 공간복잡도](#시간복잡도)
6. [참고 자료](#참고-자료)

## 정의

> key-value 쌍으로 데이터를 저장하는 자료구조.

해시 테이블(Hash Table)은 **효율적인 탐색**(빠른 탐색)을 위한 자료구조로, key-value 쌍의 데이터를 입력받는다. 해시 함수(Hash Function) `h`에 key값을 입력으로 넣어 얻은 **해시값 `h(k)`를 위치로 지정**하여 key-value 데이터 쌍을 저장한다.

### 유래 - 직접 주소화 테이블(Direct-address Table)

해시 테이블은 직접 주소화 테이블(Direct-address Table)에서 시작된 자료구조이다. 직접 주소화 테이블은 **key 값으로 k를 갖는 원소는 index k에 저장되는 데이터 매핑 방식**이다.

찾는 값과 테이블의 인덱스가 동일하여 데이터 조회, 삽입, 수정, 삭제 모두 `O(1)`의 시간복잡도를 가져 굉장히 편리하지만, 단점도 확실하다.

- 불필요한 공간 낭비  
  저장된 데이터를 제외한 테이블의 나머지 공간은 낭비된다. 즉, 테이블에 넣으려는 데이터 값의 범위보다 값의 개수가 작다면 공간 효율이 떨어진다.(낮은 적재율, low load factor)
- key가 다양한 자료형을 담을 수 없음  
  키 값을 바로 인덱스 값으로 사용하므로, 키 값이 문자열(String) 형태라면 테이블에 저장할 수 없게 된다.

직접 주소화 테이블은 이같은 단점 때문에 key-value 데이터 쌍을 저장하기에 적합하지 않았다. 이를 보완하기 위해 등장한 것이 해시 테이블이다.

## 특징

해시 테이블은 해시 함수(Hash Function) `h`를 이용해서 `(key-value)`를 `index: h(k)`에 저장한다. 이를 "**키 `k`값을 갖는 원소가 위치 `h(k)`에 해시(hash)된다.**" 또는 "**`h(k)`는 키 `k`의 해시값이다.**"라고 표현한다. **key는 반드시 존재**해야 하며, **중복되는 key가 존재해서는 안된다.**

해시 테이블을 구성하는 key-value 데이터를 저장할 수 있는 각 공간을 슬롯(slot) 또는 버킷(bucket)이라고 부른다.

## 해시의 충돌(Collision)

해시 역시 단점을 갖고 있는데, 바로 충돌(Collision)이다. 충돌은 **서로 다른 key의 해시값이 동일한 경우**를 말한다. 즉, key는 중복되지 않지만 해시값이 중복되는 경우를 충돌(Collision)이 발생했다고 한다.

따라서 충돌이 최대한 적게 일어나도록 해시 함수를 잘 설계해야 하고, 충돌이 발생하더라도 **분리 연결화(Separate Chaining)**, **개방 주소화(Open Addressing)** 등의 기법들을 사용하여 해결한다.

### 좋은 해시 함수(Hash Function)이란?

상황마다 좋은 해시 함수의 기준이 다를 수 있으나, 대략적인 기준은 '**연산 속도가 빠르고 해시값이 최대한 중복되지 않아야 한다**'라고 할 수 있다.

## 충돌 해결

해시 테이블에서 충돌 발생시 대표적으로 2가지 방법으로 해결한다.

### 개방 주소화(Open Addressing)

> 충돌이 발생하면 미리 정한 규칙에 따라 해시 테이블의 비어 있는 슬롯(slot)을 찾는다. 빈 슬롯을 찾는 방법에 따라 크게 선형 탐사법(**Linear Probing**), 제곱 탐사법(**Quadratic Probing**), 이중 해싱(**Double Hashing**)으로 나뉜다.

개방 주소화(Open Addressing) 방식은 충돌이 발생 시 정해진 규칙에 따라 빈 슬롯을 찾는다. 추가적인 메모리를 사용하지 않으므로 링크드 리스트 혹은 트리 자료구조를 통해 추가로 메모리 할당을 수행하는 **체이닝(Separete Chaining) 방식에 비해 메모리를 적게 사용**한다.

빈 슬롯을 찾는 방법에 따라 크게 3가지로 구분하면 다음과 같다.

- **선형 탐사법(Linear Probing)**  
  충돌이 발생한 해시값으로부터 **일정한 값**만큼(+1, +2, +3, ...) 건너 뛰어 비어, 있는 슬롯에 데이터를 저장한다. 충돌이 계속 발생하면 반복해서 건너뛰어 빈 슬롯을 찾는다.  
  충돌 횟수가 증가하면 특정 영역에 데이터가 집중적으로 몰리는 **클러스터링(Clustering) 현상**이 발생하는 단점이 있다. 클러스터링 현상 발생시 **평균 탐색 시간이 증가**한다.
- **제곱 탐사법(Quadratic Probing)**  
  충돌이 발생한 해시값으로부터 **제곱수**(+1^2, +2^2, +3^2, ...)로 건너 뛰어, 비어 있는 슬롯을 찾는다. 충돌이 계속 발생하면 반복해서 건너뛰어 빈 슬롯을 찾는다.  
  선형 탐사법과 동일하게 충돌 횟수가 증가하면 **클러스터링 현상**이 발생한다.
- **이중 해싱(중복 해싱, Double Hashing)**  
  **클러스터링 문제가 발생하지 않도록 2개의 해시 함수를 사용**하는 방식이다. 하나는 **최초의 해시값을 얻을 때 사용**하고, 다른 하나는 **해시 충돌이 발생할 때 탐사 이동폭을 얻기 위해 사용**한다.

### 체이닝(Separete Chaining)

> 링크드 리스트를 활용하는 방법으로, 충돌이 발생한 경우 링크드 리스트에 노드(slot)을 추가하여 데이터를 저장한다.

체이닝 방식을 사용하면 해시 테이블 연산 시 다음의 시간복잡도를 갖는다.

- **삽입**  
  서로 다른 두 key가 같은 해시값을 갖게 되면, **링크드 리스트에 노드를 추가**하여 (key-value) 데이터 쌍을 저장한다. 삽입의 시간복잡도는 `O(1)`이다.
- **검색**  
  기본적으로 `O(1)`의 시간복잡도를 가지나 <b>최악의 경우 `O(n)`</b>의 시간복잡도를 갖는다.
- **삭제**  
  선행 작업으로 검색이 필요하므로, 검색의 시간복잡도와 동일하다. 기본적으로 `O(1)`의 시간복잡도를 가지나 <b>최악의 경우 `O(n)`</b>의 시간복잡도를 갖는다.

최악의 경우(Worst Case)는 **n개의 모든 key가 동일한 해시값을 갖게 되면, 길이 n의 링크드 리스트가 생성**된다. 특정 key를 찾기 위해서는 길이 n의 링크드 리스트를 검색해야 하므로, 이 때의 <b>검색 시간복잡도는 `O(n)`</b>이 된다.

> **참고**  
> 체이닝(Separete Chaining) 방식은 기본적으로 링크드 리스트를 이용하여 데이터를 저장하나, 충돌이 많이 발생하여 링크드 리스트의 길이가 길어질 시 이진 탐색 트리(BST)를 사용하여 데이터를 저장하기도 한다. BST를 사용하면 검색 시 최악의 경우 시간복잡도를 `O(n)`에서 `O(log(n))`로 낮출 수 있다.

## 시간복잡도와 공간복잡도

- 시간복잡도

  | Operation | Average | Worst  |
  | :-------: | :-----: | :----: |
  |  Access   |  `N/A`  | `N/A`  |
  |  Search   | `Θ(1)`  | `O(n)` |
  | Insertion | `Θ(1)`  | `O(n)` |
  | Deletion  | `Θ(1)`  | `O(n)` |

  - 시간복잡도는 검색, 저장, 삭제 모두 기본적으로 `O(1)`을 갖지만, 충돌(Collision)으로 인해 최악의 경우 `O(n)`이 될 수 있다.

- 공간복잡도  
  `O(n)`
  - 공간효율성은 떨어진다. 데이터가 저장되기 전에 미리 저장공간(slot, bucket)을 확보해야 하기 때문이다. 따라서 저장공간이 부족하거나 낭비되는 부분이 많은 경우가 발생할 수 있다.

## 참고 자료

- [Hash Table에 대하여](https://lifeandit.tistory.com/112)
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
