# 동기화 문제

1. [정의](#정의)
2. [임계 영역(Critical Section)](#임계-영역critical-section)
3. [스레드의 동기화](#스레드의-동기화)
4. [동기화 기법](#동기화-기법)
   1. [유저 모드의 동기화](#유저-모드의-동기화)
      1. [임계 영역 기반의 동기화](#임계-영역-기반의-동기화)
      2. [인터락 함수 기반의 동기화](#인터락-함수-기반의-동기화)
   2. [커널 모드의 동기화](#커널-모드의-동기화)
      1. [세마포어(Semaphore)](#세마포어semaphore)
      2. [뮤텍스(Mutual Exclusion, Mutex)](#뮤텍스mutual-exclusion-mutex)
      3. [모니터(Monitor)](#모니터monitor)
5. [참고 자료](#참고-자료)

## 정의

> 경쟁 상태(Race Condition)를 해결하기 위해 프로세스/스레드가 공유하는 자원의 일관성을 유지하는 것.

서로 다른 프로세스/스레드가 한정된 공유 자원에 동시에 접근(경쟁 상태가 발생)하는 경우 엉뚱한 값을 읽거나 수정하는 문제가 발생할 수 있다. 이를 **동기화 문제**라 한다.

이같은 문제를 해결하기 위해 여러 프로세스/스레드가 공유하는 자원의 일관성을 유지시키는 것이 **동기화**이다.

## 임계 영역(Critical Section)

임계 영역은 **경쟁 상태가 발생할 수 있는 프로그램 코드 부분**을 의미한다.

임계 영역에서 동기화가 진행되지 못하면 임계 영역 문제가 발생하는데, 이를 해결하기 위한 기본 조건 3가지는 다음과 같다.

- 상호 배제(Mutual Exclusion)
  - 어떤 프로세스가 자신의 임계 영역 내에서 실행중일 때, 다른 프로세스는 각자의 임계 영역으로 진입할 수 없다.
- 진행(Progress)
  - 임계 영역에서 실행중인 프로세스가 없다면, 임계 영역으로 진입하려는 프로세스들 중 하나는 유한한 시간 내에 진입할 수 있어야 한다.
- 한정된 대기(Bounded Waiting)
  - 한 프로세스가 임계 영역에 대한 진입을 요청한 후에는 다른 프로세스의 임계 영역 진입이 유한한 횟수로 제한되어야 한다.
  - 즉, 임계 영역에 대한 진입 요청 후 무한히 기다리지 않는다.

## 스레드의 동기화

스레드의 동기화는 크게 두가지로 구분할 수 있다.

1. 실행 순서의 동기화
   - 스레드의 실행 순서를 정의하고, 이 순서를 반드시 따르도록 하는 것.
2. 메모리 접근에 대한 동기화
   - 메모리 접근에 있어서 동시 접근을 막는 것.
   - 실행의 순서는 중요치 않고, 한 순간에 하나의 스레드만 해당 자원에 접근하도록 하는 것.

## 동기화 기법

### 유저 모드의 동기화

커널의 힘을 빌리지 않는 동기화 기법(커널의 코드가 실행되지 않음)으로, 성능상의 이점이 있으나, 기능상의 제한점이 존재한다. 임계 영역 기반의 동기화, 인터락 함수 기반의 동기화가 있다.

#### 임계 영역 기반의 동기화

- 진입 허가를 받은 프로세스/스레드만 임계 영역에 들어갈 수 있다. 즉, 한번에 하나의 프로세스/스레드만 접근 가능하다.
- 임계 영역 진입을 위해 임계 영역 객체를 얻는다.
- 타 스레드가 진입 허가를 갖고 있을 시에는 반환할 때까지 블로킹된다. 진입 허가가 반환되면 브로킹 상태에서 빠져나와 진입 허가를 받고 임계 구역에 접근한다.

#### 인터락 함수 기반의 동기화

전역으로 선언된 변수 하나의 접근 방식을 동기화하는 것이 목적이라면, 이러한 용도의 특화된 인터락 함수를 사용하는 것도 좋다.

- 함수 내부적으로 한 순간에 하나의 스레드에 의해서만 실행되도록 동기화되어 있다.
- 임계 영역 기반의 동기화도 내부적으로는 인터락 함수를 기반으로 구현된다.
- 유저 모드 기반으로 동작해서 속도가 빠르다.

### 커널 모드의 동기화

커널에서 제공하는 동기화 기능을 이용하는 방법으로, 커널 모드로의 변경이 필요하고, 이는 성능 저하로 이어진다. 하지만 다양한 기능을 활용할 수 있다. 세마포어, 뮤텍스, 모니터 등이 있다.

#### 세마포어(Semaphore)

공유 자원의 데이터를 특정 개수 이상의 프로세스/스레드가 접근하는 것을 막는 방법이다.

- 동시에 접근할 수 있도록 '허용 가능한 개수'를 가지는 `Counter`을 가지고 있다.
  - 공유 자원에 접근 가능한 프로세스/스레드의 수를 나타내는 값, 공통으로 관리하는 하나의 값을 의미한다.
- 세마포어 `Counter`의 개수에 따라 다음과 같이 구분된다.
  - 1개 : Binary Semaphore
    - 바이너리 세마포어는 뮤텍스와 동일한 기능을 제공하게 된다. 따라 엄밀히 말하면 뮤텍스는 세마포어의 일종이라고 할 수 있다.
  - 2개 이상 : Counting Semaphore
- 세마포어는 자원의 상태를 나타내는 일종의 '변수'로써, 소유 개념이 아니다.
  - 세마포어를 소유하지 않은 프로세스/스레드가 세마포어를 해제할 수 있는 문제가 발생한다.

#### 뮤텍스(Mutual Exclusion, Mutex)

공유 자원의 데이터를 여러 프로세스/스레드가 접근하는 것을 막는 방법이다.

- 임계 영역을 가진 프로세스/스레드들의 Running time이 서로 겹치지 않고 각자 단독으로 실행되도록 하는 기술이다.
- **뮤텍스 객체는 두 프로세스/스레드가 동시에 사용할 수 없다.**
- 일종의 Locking 메커니즘으로, 공유 자원에 대한 접근을 조율하기 위해 Locking과 Unlocking을 사용한다.
- Lock에 대한 소유권이 있으며 Lock을 가지고 있는 경우에만 공유 자원에 접근할 수 있고, Lock을 가진 프로세스/스레드만 반환할 수 있다.
- 뮤텍스는 단 하나의 Lock만 존재한다. 따라서 Lock을 소유해야만 자원에 접근이 가능하고, 타 프로세스/스레드는 자원에 접근하기 위해서는 Lock을 반환을 기다려야만 한다.

#### 모니터(Monitor)

- Mutex(Lock)와 Condition Variables를 가지고 있는 동기화 매커니즘이다.

> **세마포어와 뮤텍스의 차이**
>
> - 세마포어는 뮤텍스가 될 수 있으나, 뮤텍스는 세마포어가 될 수 없다.
> - 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 그 책임을 진다.
> - 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 뮤텍스를 해제할 수 있다. 반면 세마포어는 소유하지 않고 있는 다른 스레드가 세마포어를 해제할 수 있다.
> - 뮤텍스는 동기화 대상이 1개일 때 사용하고, 세마포어는 동기화 대상이 여러개일 때 사용한다.

> **세마포어와 모니터의 차이**
>
> - 자바에서는 모니터를 모든 객체에 기본으로 제공하나, C에서는 사용할 수 없다.
> - 세마포어는 카운터라는 변수값으로 프로그래머가 상호 배제나 정렬의 목적으로 사용시 매번 값을 별도로 지정해줘야 하는 등 조금 번거롭다.
> - 반면, 모니터는 이러한 작업이 캡슐화되어 있어서 개발자는 카운터 값을 0 또는 1로 지정하는 고민 없이 synchronized, wait(), notify() 등의 키워드를 이용해 조금 더 편하게 동기화할 수 있다.

## 참고 자료

- [동기화 문제](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%EB%8F%99%EA%B8%B0%ED%99%94%20%EB%AC%B8%EC%A0%9C.md)
- [프로세스 동기화 (Process Synchronization)](https://jungwoon.github.io/os/2019/07/31/Process-Synchronization.html)
- [[13. 쓰레드 동기화 기법]](https://popcorntree.tistory.com/65)
- [[OS] 동기화 객체의 종류](https://velog.io/@ragnarok_code/OS-%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%A2%85%EB%A5%98)
- [프로세스 동기화(뮤텍스,세마포어,임계구역)](https://dduddublog.tistory.com/25)
